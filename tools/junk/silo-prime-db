#!/usr/bin/env ruby

# This program trundles through a disk-based silo and initializes 
# database-backed version of the silo.  It uses the silo metadata
# files - that is, md5 and sha1s are not recomputed, just read from
# the associated file and placed in the DB.
#
# Note that the database is expected to be clean of pre-existing
# entries in the packages and histories tables before we do this
# (for the silo being primed).
# TODO: make sure!


require 'digest/md5'
require 'digest/sha1'
require 'optparse'
require 'ostruct'
require 'store/db'
require 'store/logger'
require 'store/silo'
require 'store/silodb'
require 'yaml'


exit unless (conf = StoreUtils.get_silo_options(ARGV))

if conf.syslog_facility
  Logger.facility  = conf.syslog_facility
else
  Logger.stderr
end

begin
  Store::SiloDB.setup conf.db_configuration_file, conf.db_configuration_key
rescue => e
  STDERR.puts e.message
  exit
end

if not Store::SiloDB.hosts.include?(conf.hostname)                  # hostname doesn't even exist, create hostname:filesystem
  Store::SiloDB.create(conf.hostname, conf.silo_path)
  Logger.warn "Adding new silo entry for #{conf.hostname}:#{conf.silo_path} to db."
else
  found = false
  Store::SiloDB.silos(conf.hostname).each do |silo_record|          # search for this hostname:filesystem
    found ||= silo_record.filesystem == conf.silo_path
  end
  if not found                                               # well, create hostname:filesystem
    Store::SiloDB.create(conf.hostname, conf.silo_path)
    Logger.warn "Adding new silo entry for #{conf.hostname}:#{conf.silo_path} to db."
  end
end

# TODO:  we really should not add a put record if one already exists.

begin
  silo   = Store::Silo.new(conf.silo_path)
  record = Store::DB::SiloRecord.lookup conf.hostname, conf.silo_path

  raise "Can't get db record for hostname #{conf.hostname}, path #{conf.silo_path}." if record.nil?

  Logger.info "Migrating #{silo} data to SiloDB/SiloTape database #{record}."

  silo.each do |name|
    Store::DB::HistoryRecord.put record, name, { :md5 => silo.md5(name), :sha1 => silo.sha1(name), 
                                                 :size => silo.size(name), :type => silo.type(name),
                                                 :timestamp => silo.datetime(name) }
  end
rescue => e
  Logger.err e.message
end

  


