#!/usr/bin/env ruby

# Start at a driver program: find the disk-idling guys first, do one of them; if
# none, go at the tape masters that are older than 30 days, oldest first.

require 'optparse'

$LOAD_PATH.unshift File.expand_path(File.join(File.dirname(__FILE__), '../lib'))

require 'store/silodb'
require 'store/silotape'

Struct.new('Options', :db_config_file, :db_config_key, :web_server)

def get_options args
  conf = Struct::Options.new

  conf.db_config_file = '/opt/fda/etc/db.yml'         # defaults
  conf.db_config_key  = 'silo_test'
  conf.web_server     = case Socket::gethostname.downcase
                        when 'fclnx30.fcla.edu'; 'silos.darchive.fcla.edu'
                        when 'fclnx31.fcla.edu'; 'silos.tarchive.fcla.edu'
                        end

  opts = OptionParser.new do |opts|
    str = "The name of the web server using this silo"
    opts.on("--web-server HOST",  String, (conf.web_server ? str + " (defaults to " + conf.web_server + ")." : str + ", required.")) do |host|
      conf.web_server = host
    end
    opts.on("--db-config-file FILEPATH", String, "Filename of database configuration data (defaults to #{conf.db_config_file}).") do |filepath|
      conf.db_config_file = filepath
      raise "#{conf.db_config_file} doesn't exist."   unless File.exists? filepath
      raise "#{conf.db_config_file} isn't readable."  unless File.readable? filepath
    end
    opts.on("--db-config-key KEY", String, "The key into the file of database configuration data (defaults to #{conf.db_config_key}).") do |key|
      conf.db_config_key = key
    end    
  end
  opts.parse!(args) 
  raise "No web server name specified."  unless conf.web_server
rescue => e
  STDERR.puts e, opts
  exit
else
  return conf
end

options = get_options(ARGV)

Store::DB.setup(options.db_config_file, options.db_config_key)    

# Disk silos only

Struct.new('SiloInfo', :name, :oldest_fixity, :state)
info = []

Store::SiloTape.silos(options.web_server).each do |rec| 
  silo =  Store::SiloTape.new(rec.hostname, rec.filesystem, '/tmp/', 'UNUSED')
  next unless silo.oldest_fixity  # means no existing packages....
  info.push Struct::SiloInfo.new(silo.hostname + ':' + silo.filesystem, silo.oldest_fixity, silo.state)
end

info.sort! { |a,b| a.oldest_fixity <=> b.oldest_fixity }

puts "All silos: "
info.each do |rec|
  puts '  ' + rec.name + " (" + rec.state.to_s + ")\t" + rec.oldest_fixity.strftime('%Y-%m-%d %X')
end

days = 30
puts "Tape masters that need to be checked (over #{days} days): "
now = DateTime.now

info.select{ |rec| (now - rec.oldest_fixity > days) and (rec.name !~ /666/) and (rec.state == :tape_master) }.each do |rec|
  puts '  ' + rec.name + " (" + rec.state.to_s + ")\t" + rec.oldest_fixity.strftime('%Y-%m-%d %X')
end
