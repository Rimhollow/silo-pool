#!/usr/bin/env ruby

$LOAD_PATH.unshift      File.expand_path(File.join(File.dirname(__FILE__), '..', 'lib'))

# This program trundles through one or more disk-based silos and does md5 and sha1 checksums,
# adding them to thea SiloDB/SiloTape  database.

# TODO: extend DB to allow recording current size, as well

require 'datyl/logger'
require 'datyl/reporter'
require 'digest/md5'
require 'digest/sha1'
require 'optparse'
require 'store/silodb'
require 'store/utils'

# Get options from the command line; here's what we're shooting for:
#
# Usage: disk-fixity [ --options ] [ /silo/001 .. ]
#        without an explicit list of disk silos, do checks on all of them. Write a simple report of results when done.
#         --hostname HOST              Required, the name of the host this silo is associated with (usually a virtual host)
#         --fresh-enough DAYS          If a fixity check has been done in less than the supplied DAYS, don't do another (defaults to 7)
#         --pid-directory PATH         Optionally, a directory for storing this scripts PID for external moitoring agents, such as xymon
#         --db-config-file PATH        A database yaml configuration file, defaults to /opt/fda/etc/db.yml
#         --db-config-key KEY          The key for the database information in the database yaml configuration file /opt/fda/etc/db.yml
#         --syslog-facility FACILITY   The facility in syslog to log to, otherwise log to STDERR
#         --randomize                  Randomize the order of silos checked. Normally silos are sorted by the time of the last completed fixity check

def get_options args
  conf = OpenStruct.new(:hostname => nil, :syslog_facility => nil, :db_config_key => nil, :db_config_file => '/opt/fda/etc/db.yml', :fresh_enough => 7, :pid_directory => nil, :randomize => false)

  opts = OptionParser.new do |opts|

    opts.banner = "Usage: #{$0.sub(%r{.*/}, '')} [ --options ] [ /silo/001 .. ]\n" +
                  "       without an explicit list of disk silos, do checks on all of them."

    opts.on("--hostname HOST",   String, "Required, the name of the host this silo is associated with (usually a virtual host)") do |hostname|
      conf.hostname = hostname.downcase
    end

    opts.on("--fresh-enough DAYS",  Integer, "If a fixity check has been done in less than the supplied DAYS, don't do another (defaults to #{conf.fresh_enough})") do |days|
      conf.fresh_enough = days
    end

    opts.on("--pid-directory PATH", String, "Optionally, a directory for storing this scripts PID for external moitoring agents, such as xymon") do |path|
      conf.pid_directory = path
    end
    
    opts.on("--db-config-file PATH",  String, "A database yaml configuration file, defaults to #{conf.db_config_file}") do |path|
      conf.db_config_file = path
    end
    
    opts.on("--db-config-key KEY",  String, "The key for the database information in the database yaml configuration file #{conf.db_config_file}") do |key|
      conf.db_config_key = key
    end

    opts.on("--syslog-facility FACILITY",  String, "The facility in syslog to log to, otherwise log to STDERR") do |facility|
      conf.syslog_facility = facility
    end

    opts.on("--randomize",  "Randomize the order of silos checked. Normally silos are sorted by the time of the last completed fixity check") do |rnd|
      conf.randomize = rnd
    end
  end
  opts.parse!(args) 
  raise "No hostname provided"  unless conf.hostname
  raise "No key into the DB configuration file (#{conf.db_config_file}) provided" unless conf.db_config_key
  raise "Default yaml file #{conf.db_config_file} not found" unless File.exists?   conf.db_config_file
  raise "Default yaml file #{conf.db_config_file} not readable" unless File.readable? conf.db_config_file
  
rescue => e
  STDERR.puts e, opts
  exit 1
else
  return conf
end


# setup(config) initializes logging and reporting, connects to the database, sets up signal handlers, and writes a process id to a run-file, if so configured.

def setup config

  $0 = 'disk-fixity'

  Logger.setup('DiskFixity', config.hostname)

  if config.syslog_facility
    Logger.facility  = config.syslog_facility 
  else
    Logger.stderr   
  end

  if config.pid_directory
    pid_path = StoreUtils.pid_file(config.pid_directory)
    raise "PID file #{pid_path} exists. This indicates another copy of this program is running or has previously crashed; exiting"   if File.exists? pid_path
    File.open(pid_path, 'w') { |file|  file.puts $$ }
  end

  begin
    Store::SiloDB.setup config.db_config_file, config.db_config_key
  rescue => e
    Logger.err e.message
    exit
  end

  Kernel.trap('INT')  { Logger.err "Interrupted"  ; exit }  # leaves the pid file, if one is being used
  Kernel.trap('HUP')  { teardown(config); exit }             # do a clean shutdown with these:
  Kernel.trap('PIPE') { teardown(config); exit } 

  Reporter.max_lines_to_write = 100    # each report will have at most these lines, though everything will go to syslog
  return Reporter.new('Disk Fixity Checks')
end

# teardown will clear the run-file that xymon checks.  If we crash, xymon will let us know.

def teardown config
  if config.pid_directory
    pid_path = StoreUtils.pid_file(config.pid_directory)
    File.delete pid_path if File.exists? pid_path and File.writable? pid_path
  end
end

# Order the disk silos by oldest completed fixity time, latest first; if silos have been specified on the command line, restrict our list to just those.

def select_silos config, reporter
  silos = Store::DB::SiloRecord.list(config.hostname).select{ |s| s.state == :disk_master }.map{ |rec| Store::SiloDB.new(rec.hostname, rec.filesystem) }
  candidates = ARGV.map { |s| s.sub(%r{/+$}, '') }
  silos = silos.select { |s| candidates.include? s.filesystem } unless candidates.empty?
  silos = silos.select { |s| s.oldest_fixity }.sort{ |a,b| a.oldest_fixity <=> b.oldest_fixity }
  return silos.sort { rand } if config.randomize
  return silos
rescue => e
  reporter.error "Failed selecting the list of silos to process:"
  reporter.error "#{e.class} #{e.message}, backtrace follows:"
  e.backtrace.each { |line| reporter.error "  #{line}" }
  reporter.write
  exit                 # skip teardown so we leave pid file - makes sure xymon will squawk
end

class Counter
  attr_accessor  :skipped, :errors, :ok, :total
  def initialize
    @skipped = @errors = @ok = @total = 0
  end
end
  
config   = get_options(ARGV)
reporter = setup(config)


silos    = select_silos(config, reporter)

if silos.empty?                                                   # TODO: prettier output here
  reporter.warn "There were no silos available to process for #{config.hostname}."
  reporter.warn "Configuration options: #{config.inspect}."
  reporter.warn "Silos specified on the command line: #{ARGV * ', '}." unless ARGV.empty?
else
  reporter.info "Checking the following silos for #{config.hostname} by last fixity check date:" 
  silos.each { |silo| reporter.info "  * #{silo.filesystem} - #{silo.oldest_fixity.strftime('%A, %B %d, %Y at %r')}" }
  reporter.info "Will skip packages if checked within #{config.fresh_enough} days." if config.fresh_enough > 0   # TODO plural check, commify
end

silos.each do |silo|
  reporter.info
  reporter.info "Beginning bulk fixity update for silo #{silo.filesystem}"
  reporter.info DateTime.now.strftime("Starting silo  #{silo.filesystem} on %A, %B %d, %Y at %r")
  counter = Counter.new  

  silo.each_package_record do |package|
    counter.total += 1
    if (package.initial_timestamp != package.latest_timestamp) and (DateTime.now - package.latest_timestamp) <  config.fresh_enough 
      counter.skipped += 1
      next
    end
    begin
      md5  = Digest::MD5.new
      sha1 = Digest::SHA1.new
      silo.get(package.name) do |buff|
        md5  << buff
        sha1 << buff
      end
      md5   = md5.hexdigest
      sha1  = sha1.hexdigest
    rescue => e    
      reporter.err "Unexpected error checking #{package.name} on silo #{silo.filesystem}:"
      reporter.err "  #{e.class}: #{e.message}"
      counter.errors += 1
    else
      silo.fixity(package.name, :md5 => md5, :sha1 => sha1)
      errors = []
      errors.push "md5 mismatch - expected #{silo.md5(package.name)} but got #{md5}"    if (md5  != silo.md5(package.name))
      errors.push "sha1 mismatch - expected #{silo.sha1(package.name)} but got #{sha1}" if (sha1 != silo.sha1(package.name))
      if errors.empty?
        counter.ok += 1
      else
        counter.errors += 1
        reporter.err "Fixity failure for #{package.name} on silo #{silo.fileystem}:"
        errors.each { |line|  reporter.err "  #{line}" }
      end
    end
  end  
  reporter.info DateTime.now.strftime("Completed silo #{silo.filesystem} on %A, %B %d, %Y at %r")
  reporter.info "Total of #{counter.total} packages: #{counter.skipped} skipped, #{counter.ok} succeeded, #{counter.errors} failed"  # TODO: commify, pluralize
  reporter.info 
end

reporter.write
teardown(config)
