#!/usr/bin/env ruby

# TODO: add randomize option, like disk-fixity
#

# Store::FatalFixityError is used when we encounter an issue that we
# can give a reasonable diagnostic; otherwise we'll produce a
# backtrace

# TODO: when doing the major refactoring, use the more recently
# written stream module written for StoreMaster; these are yield based
# and easier on resident memeory.

require 'digest/md5'
require 'digest/sha1'
require 'enumerator'
require 'fileutils'
require 'find'
require 'net/smtp'
require 'optparse'
require 'socket'
require 'tempfile'
require 'time'

$LOAD_PATH.unshift File.expand_path(File.join(File.dirname(__FILE__), '../lib'))

require 'datyl/reporter'
require 'datyl/streams'
require 'store/db'
require 'store/exceptions'
require 'store/fixityutils'
require 'store/silo'
require 'store/silodb'
require 'store/silotape'
require 'store/tsmexecutor'

Struct.new('Options', :fixity_disk, :db_config_file, :db_config_key, :web_server, :syslog_facility, :tape_server, :user, :grace_period, :fresh_enough, :pid_directory)

# The defaults defined here pretty good; you may want to specify the syslog.

def get_options args

  conf = Struct::Options.new

  # defaults:

  conf.db_config_file = '/opt/fda/etc/db.yml'
  conf.db_config_key  = 'production_silo'
  conf.fixity_disk    = (DateTime.now.jd % 2 == 0) ? '/daitssfs/fixity/0/' : '/daitssfs/fixity/1/'
  conf.fresh_enough   = 7
  conf.grace_period   = 45
  conf.user           = 'silo'
  conf.pid_directory  = nil
  conf.tape_server    = case Socket.gethostname.downcase
                        when 'fclnx30.fcla.edu'; 'BERNARD_SERVER'
                        when 'fclnx31.fcla.edu'; 'BIANCA_SERVER'
                        end
  conf.web_server     = case Socket::gethostname.downcase
                        when 'fclnx30.fcla.edu'; 'silos.darchive.fcla.edu'
                        when 'fclnx31.fcla.edu'; 'silos.tarchive.fcla.edu'
                        end

  # get/override with user-specified values:

  opts = OptionParser.new do |opts|

    opts.on("--fixity-disk NUM",  String, "One of the two fixity scratch disks, 0 or 1 (defaults to #{conf.fixity_disk}, today).") do |num|
      conf.fixity_disk =
        case num
        when '0';  '/daitssfs/fixity/0/'
        when '1';  '/daitssfs/fixity/1/'
        else
          raise "fixity disk must be one of '0' or '1'"
        end
    end

    str = "The name of the web server using this silo"

    opts.on("--web-server HOST",  String, (conf.web_server ? str + " (defaults to " + conf.web_server + ")." : str + ", required.")) do |host|
      conf.web_server = host
    end

    opts.on("--db-config-file FILEPATH", String, "Filename of database configuration data (defaults to #{conf.db_config_file}).") do |filepath|
      conf.db_config_file = filepath
      if not File.exists? filepath
        raise "#{conf.db_config_file} doesn't exist."
      end
      if not File.readable? filepath
        raise "#{conf.db_config_file} isn't readable."
      end
    end

    opts.on("--pid-directory PATH", String, "Optionally, a directory for storing this scripts PID for external moitoring agents, such as xymon") do |path|
      conf.pid_directory = path
    end
    
    opts.on("--db-config-key KEY", String, "The key into the file of database configuration data (defaults to #{conf.db_config_key}).") do |key|
      conf.db_config_key = key
    end

    opts.on("--fresh-enough DAYS",  Integer, "If a fixity check has been done in less than the supplied DAYS, don't do another (defaults to #{conf.fresh_enough})") do |days|
      conf.fresh_enough = days
    end

    opts.on("--grace-period DAYS", String, "The number of days since the earliest fixity on a tape silo after which we'll recheck the fixities (defaults to #{conf.grace_period}).") do |days|
      conf.grace_period = days.to_i
    end

    opts.on("--syslog-facility FACILITY", String, "The syslog facility with which to log, e.g., LOG_LOCAL0 (if none, log to STDERR).") do |facility|
      conf.syslog_facility = facility
    end

    opts.on("--tape-server NAME", String, "The name of the tivloi tape server (defaults to #{conf.tape_server}).") do |name|
      conf.tape_server = name
    end

    opts.on("--user NAME", String, "The user this process must run as (defaults to #{conf.user}).") do |name|
      conf.user = name
    end
  end

  opts.parse!(args)
  raise "No web server name specified."  unless conf.web_server

rescue => e
  STDERR.puts e, opts
  exit 1
else
  return conf
end


Struct.new('FindStreamRecord', :path, :size, :mtime)

# List all of the files from a silo (except for .lock files). Data is returned as a list of arrays,
# where the first element (key) is the path; and the second element (value) is a struct containing .path, a string; .mtime, a Time object;  and .size, a fixnum.
#
#   [ "/daitssfs/002/113/f0f4d29507f3049999b756bfb4215/data", #<struct  path="/daitssfs/002/113/f0f4d29507f3049999b756bfb4215/data", size=110023, mtime="Thu Jun 24 13:22:36 -0400 2010"> ],
#   [ "/daitssfs/002/4e6/5e0f51a7f2c81cb4b5a6c3fa169c8/sha1", #<struct  path="/daitssfs/002/4e6/5e0f51a7f2c81cb4b5a6c3fa169c8/sha1", size=41,     mtime="Thu Jun 24 13:36:09 -0400 2010"> ],
#   etc...
#

class FindStream < ArrayBasedStream

  def initialize filesystem
    @index = 0
    @list  = []

    Find.find(filesystem) do |path|
      next if File.directory? path
      next if path =~ /\.lock$/
      stat = File.stat path
      @list.push [ path, Struct::FindStreamRecord.new(path, stat.size, stat.mtime) ]
    end
    @list.sort! { |a, b|  a[0] <=> b[0] }
  end
end

class TsmStream < ArrayBasedStream

  # tsm.list returns an array of Structs, with accessors .path (String), .mtime (Time), .size (Fixnum) - sorted on .path
  # we just have to break out the path as key.

  def initialize filesystem, tape_server, reporter
    @index = 0
    @list  = []
    filesystem = filesystem.gsub(%r{/+$}, '') + '/'

    tsm = Store::TsmExecutor.new(tape_server, 120)
    tsm.list(filesystem).each do |rec|
      @list.push [ rec.path, rec ] unless rec.path =~ /\.lock$/
    end

    # list is sorted by tsm.list; status of 0 or 4 is OK; 8 may
    # be. 12 definitely isn't.

    if tsm.status > 8
      reporter.err "Command '#{tsm.command}', exited with status #{tsm.status}. This is a fatal error and processing will be stopped."
      if not tsm.errors.empty?
        reporter.err "Tivoli error log follows:"
        tsm.errors.each { |line| reporter.err line.chomp }
      end
      if not tsm.output.empty?
        reporter.err "Tivoli output log follows:"
        tsm.output.each { |line| reporter.err line.chomp }
      end
      reporter.err "An error occured in Tivoli processing. Giving up on fixity checking this tape."
      raise FatalFixityError, "Can't continue - Tivloi reported errors"

    elsif tsm.status > 4
      reporter.warn "Command '#{tsm.command}', exited with status #{tsm.status}. Some warnings occured.  Check the following Tivoli log messages if fixity errors occur."
      if not tsm.errors.empty?
        reporter.warn "Tivoli error log follows:"
        tsm.errors.each { |line| reporter.warn line.chomp }
      end
      if not tsm.output.empty?
        reporter.warn "Tivoli output log follows:"
        tsm.output.each { |line| reporter.warn line.chomp }
      end
    end
  end
end


# TODO: remove this and use more general state changes listed in silomixin

def set_to_tape_master hostname, silo
  rec = Store::DB::SiloRecord.lookup(hostname, silo)
  raise Store::FatalFixityError, "Can't get DB entry for #{hostname}:#{silo}." if rec.nil?
  rec.make_tape_master
end


# Set up everything, doing some basic sanity checks; returns a reporter object.

def setup config
  $0 = 'tape-fixity'

  Logger.setup('TapeFixity', config.web_server)

  if config.pid_directory
    pid_path = StoreUtils.pid_file(config.pid_directory)
    raise "PID file #{pid_path} exists. This indicates another copy of this program is running or has previously crashed; exiting"   if File.exists? pid_path
    File.open(pid_path, 'w') { |file|  file.puts $$ }
  end

  if config.syslog_facility
    Logger.facility = config.syslog_facility
  else
    Logger.stderr
  end

  me = Etc.getpwuid(Process.uid).name
  raise "This program must be run as the #{config.user} user, but is being run as #{me}." unless  me == config.user

  Store::DB.setup(config.db_config_file, config.db_config_key)

  raise "The specified fixity disk #{config.fixity_disk} doesn't exist."                unless File.directory? config.fixity_disk
  raise "The #{config.user} user can't read the fixity disk #{config.fixity_disk}."     unless File.readable?  config.fixity_disk
  raise "The #{config.user} user can't write to the fixity disk #{config.fixity_disk}." unless File.writeable? config.fixity_disk


  Kernel.trap('INT')  { Logger.err "Interrupted"  ; exit }  # leaves the pid file, if one is being used
  Kernel.trap('HUP')  { teardown(config); exit }             # do a clean shutdown with these:
  Kernel.trap('PIPE') { teardown(config); exit } 

  Reporter.max_lines_to_write = 100    # each report will have at most these lines, though everything will go to syslog
  return Reporter.new('Tape Fixity Checks')

rescue => e
  raise Store::FatalFixityError, "#{e.class}: #{e.message}" 

end

# teardown(config) will clear our run-file.

def teardown config
  if config.pid_directory
    pid_path = StoreUtils.pid_file(config.pid_directory)
    File.delete pid_path if File.exists? pid_path and File.writable? pid_path
  end
end



Struct.new('SiloInfo', :filesystem, :oldest_fixity, :state)

# Select a silo to work on.  We'll

def select_silo host, tape_server, grace_period, reporter
  info = []

  Store::SiloTape.silos(host).each do |rec|
    silo =  Store::SiloTape.new(rec.hostname, rec.filesystem, '/tmp/', tape_server)   # TODO: /tmp?
    info.push Struct::SiloInfo.new(silo.filesystem, silo.oldest_fixity, silo.state) if silo.oldest_fixity   # no packages to check
  end

  info.sort! { |a,b| a.oldest_fixity <=> b.oldest_fixity }

  now = DateTime.now

  tape_masters = info.select{ |rec| (now - rec.oldest_fixity > grace_period) and (rec.state == :tape_master) }
  disk_idlers  = info.select{ |rec| rec.state == :disk_idling }

  silo_info = nil

  if tape_masters.count > 0
    if tape_masters.count == 1
      reporter.info "There is one tape master that hasn't been completely fixity-checked in #{grace_period} days:"
    else
      reporter.info "There are #{tape_masters.count} tape masters that haven't been completely fixity-checked in #{grace_period} days:"
    end
    tape_masters.map { |si| si.filesystem }.sort.each_slice(4) { |slice| reporter.info slice.join(' ') }
    silo_info = tape_masters[0]
  else
    reporter.info "All tape masters for #{host} have been completely fixity-checked within the last #{grace_period} days."
  end

  if disk_idlers.count > 0
    if disk_idlers.count == 1
      reporter.info  "There is one disk silo ready for tape mastering:"
    else
      reporter.info  "There are #{disk_idlers.count} disk silos ready for tape mastering:"
    end
    disk_idlers.map { |si| si.filesystem }.sort.each_slice(4) { |slice| reporter.info slice.join(' ') }
    silo_info = disk_idlers[0]
  else
    reporter.info  "There are no disk silos ready for tape mastering."
  end

  silo_info
end

# Tivoli will give us only those active files; The original disk parition for the silo is still mounted at this point.
#
# Note:  tivoli will change the time format in its reports based on localization environment. This will
# bite you running from a crontab.  Be sure to set something like:
#
#  export LANG=en_US.UTF-8
#  

def check_tivoli_file_list  web_server, tape_server, silo, reporter

  reporter.info "Comparing file information (date, size, name) from disk #{silo} against the tivoli backup report."

  missing_from_tape = []
  missing_from_disk = []

  error_count   = 0
  warning_count = 0
  total_count   = 0

  on_tape = TsmStream.new(silo, tape_server, reporter)
  on_disk = FindStream.new(silo)

  ComparisonStream.new(on_tape, on_disk).get do |path, tape_record, disk_record|

    total_count += 1

    if not disk_record
      missing_from_disk.push tape_record   # .path, .mtime, .size

    elsif not tape_record
      missing_from_tape.push disk_record   # .path, .mtime, .size

    else
      # Time.parse gets confused with the tivoli times, getting the wrong offset (uses the current daylight/standard
      # setting, apparently) - we strip that off here.

      if disk_record.mtime.localtime.iso8601[0..18] !=  tape_record.mtime.localtime.iso8601[0..18]
        reporter.err "The date for #{tape_record.path} on tape differs from disk -  #{tape_record.mtime}  on tape, #{disk_record.mtime} on disk."
        error_count += 1
      end

      if tape_record.size  != disk_record.size
        reporter.err "The size for #{tape_record.path} on tape differs from disk - #{tape_record.size} on tape, #{disk_record.size} on disk."
        error_count += 1
      end
    end
  end

  if not missing_from_tape.empty?
    count = missing_from_tape.count
    warning_count += count
    reporter.warn "Had #{count} #{pluralize_maybe(count, 'file')} missing from tape - there should be none. List follows:"
    missing_from_tape.each { |rec| reporter.warn rec.path }
  end

  if not missing_from_disk.empty?
    count = missing_from_disk.count
    warning_count += count
    reporter.warn "Had #{count} #{pluralize_maybe(count, 'file')} missing from disk - there should be none. List follows:"
    missing_from_disk.each { |rec| reporter.warn rec.path  }
  end

  if (warning_count + error_count) > 0
    reporter.warn "Silo #{silo} can't be processed, the tape backup isn't up to date. We'll try again tomorrow."
    return false
  else
    reporter.info "Tape backup for silo #{silo} appears to be up to date, #{total_count} files checked against the tivoli backup listing."
    return true
  end
end


def do_tape_silo_fixity_check silo, config, reporter

  restore_to_scratch_disk(config.tape_server, silo, config.fixity_disk, reporter)

  if not check_package_fixities(config.web_server, silo, config.fixity_disk, reporter)
    raise Store::FatalFixityError, "Fixity failure: can't continue with fixity check for silo #{silo} on filesystem #{config.fixity_disk}."
  end

  info = check_for_missing(config.web_server, silo, config.fixity_disk, reporter)

  if info.missing > 0
    raise Store::FatalFixityError, "Missing packages during tape-based fixity check for silo #{silo}, data was restored to filesystem #{config.fixity_disk}."
  end
end

# silo: '/daitssfs/001', config: the config config, reporter: logs and caches an abbreviated report

def do_tape_master_fixity_check silo, config, reporter

  if not check_tivoli_file_list(config.web_server, config.tape_server, silo, reporter)
    raise Store::FatalFixityError, "The file listing for the on-disk silo #{silo} doesn't match the listing provided by Tivoli."
  end

  # At this point we know the Tivoli file list matches the on-disk
  # silo for names, modification dates, and sizes.  Before we do any
  # restoring, let's check that the on-disk data is consistent with
  # our database (takes a few minutes).

  info = check_for_missing(config.web_server, silo, silo, reporter)

  if (info.ghosts > 0) or (info.missing > 0) or (info.aliens > 0)
    reporter.err "The on-disk silo #{silo} has #{info.ghosts} #{pluralize_maybe(info.ghosts, 'package')} on disk that the database indicates should have been deleted."     if info.ghosts  > 0
    reporter.err "The on-disk silo #{silo} has #{info.aliens} #{pluralize_maybe(info.aliens, 'package')} that there is no record of in the database."                       if info.aliens  > 0
    reporter.err "The on-disk silo #{silo} has #{info.missing} #{pluralize_maybe(info.missing, 'package')} missing from disk that the database indicates should be there."  if info.missing > 0
    raise "The on-disk silo #{silo} is inconsistent (see log); we can't proceed with tape-mastering until these issues are resolved."
  end

  restore_to_scratch_disk(config.tape_server, silo, config.fixity_disk, reporter)

  # At this point Tivoli has restored from tape to scratch disk
  # without reporting errors.  We make sure the files on scratch disk
  # jibe with what the DB says should be there, just as we did for the
  # silo on-disk packages, above. We've then established DISK <=> DB
  # <=> TAPE where "<=>" means "same packages present". (Note that
  # here we are most interested in preserved packages, excluding
  # aliens and ghosts.  While aliens and ghosts should not be there
  # when we're mastering, we expect them to accumulate over time.)

  info = check_for_missing(config.web_server, silo, config.fixity_disk, reporter)

  reporter.warn "The restored silo #{silo} on filesystem #{config.fixity_disk} has #{info.ghosts} #{pluralize_maybe(info.ghosts, 'package')} that the database indicates should have been deleted."     if info.ghosts > 0
  reporter.warn "The restored silo #{silo} on filesystem #{config.fixity_disk} has #{info.aliens} #{pluralize_maybe(info.aliens, 'package')} that there is no record of in the database."               if info.aliens > 0

  if info.missing > 0
    reporter.err "The restored silo #{silo} on filesystem #{config.fixity_disk} has #{info.missing} missing #{pluralize_maybe(info.missing, 'package')}."
    raise Store::FatalFixityError, "While tape-mastering, the restored silo #{silo} on filesystem #{config.fixity_disk} was inconsistent (see log); cannot proceed with until issues are resolved."
  end

  # Fixity check the packages on the restored silo; if successful, we're done.

  if not check_package_fixities(config.web_server, silo, config.fixity_disk, reporter)
    raise Store::FatalFixityError, "While tape-mastering, one or more of the packages for #{silo} restored to #{config.fixity_disk} failed the fixity check (see log for details)."
  end

  # Looks great; we're done

  set_to_tape_master(config.web_server, silo)
end

begin
  config   = get_options(ARGV)
  reporter = setup(config)
  silodata = nil

  reporter.info "Starting tape fixity checks, using Tivoli server #{config.tape_server}, fixity disk #{config.fixity_disk}"

  clean_up_scratch_disk(config.fixity_disk, reporter)

  silodata = select_silo(config.web_server, config.tape_server, config.grace_period)

  if silodata.nil?
    reporter.info "No silos need checking."
  elsif silodata.state == :disk_idling
    reporter.info "Selected disk-idling silo #{silodata.filesystem} for conversion to tape master, server #{config.web_server}."
    do_tape_master_fixity_check silodata.filesystem, config, reporter
  elsif silodata.state == :tape_master
    reporter.info "Selected #{silodata.filesystem} for doing a routine fixity check, server #{config.web_server}."
    do_tape_silo_fixity_check silodata.filesystem, config, reporter
  else
    raise Store::FatalFixityError, "Unexpected silo state encountered while selected a silo to process: #{silodata}."
  end

rescue Store::FatalFixityError => e
  reporter.err "Fatal error: #{e}"
rescue => e
  reporter.err "Fatal error: #{e}, back trace follows:"
  e.backtrace.each { |line| reporter.err line.chomp }
else
  reporter.info "Finished checking silo #{silodata.filesystem}."
  reporter.write
  teardown(config)
end
